<!doctype html>
<html lang="en-US">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>NASA FITS Explorer</title>
		<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='8' fill='%230f172a'/%3E%3Cpath fill='%23facc15' d='M16 4l3.4 7 7.6.7-5.8 5.2 1.8 7.6-7-4.2-7 4.2 1.8-7.6-5.8-5.2 7.6-.7z'/%3E%3C/svg%3E" />
		<link rel="stylesheet" href="/static/styles.css" />
		<link rel="stylesheet" href="https://aladin.cds.unistra.fr/AladinLite/api/v3/latest/aladin.min.css" />
		<script src="https://aladin.cds.unistra.fr/AladinLite/api/v3/latest/aladin.js"></script>
	</head>
	<body>
		<div id="aladin-lite-div" aria-label="Interactive FITS viewer"></div>
		<aside class="hud" aria-live="polite">
			<p class="title">NASA FITS Explorer</p>
			<p class="status" id="status-message">Select a FITS source to start exploring.</p>
			<div class="controls">
				<label class="file-picker">
					<input id="fits-file" type="file" accept=".fits,.fit,application/fits" />
					<span>Open local FITS file</span>
				</label>
				<div class="url-loader">
					<input id="fits-url" type="url" placeholder="https://data.nasa.gov/sample.fits" aria-label="FITS file URL" />
					<button type="button" id="load-url">Load URL</button>
				</div>
				<div class="marker-actions">
					<button type="button" id="add-marker" class="marker-control">Add marker</button>
					<button type="button" id="remove-marker" class="marker-control">Remove marker</button>
				</div>
			</div>
			<div class="samples">
				<span class="samples-label">Try a sample dataset:</span>
				<div class="sample-buttons">
					<button
						type="button"
						data-fits-url="https://cdsarc.cds.unistra.fr/saadavizier/download?oid=864972989978905533"
						data-label="WISE Infrared — IC 434 & Horsehead Nebula"
						data-colormap="magma"
					>
						Horsehead Nebula (WISE)
					</button>
					<button
						type="button"
						data-fits-url="https://fits.gsfc.nasa.gov/samples/NGC6543.fits"
						data-label="HST WFPC2 — NGC 6543 (Cat's Eye)"
						data-colormap="viridis"
					>
						Cat's Eye Nebula (HST)
					</button>
					<button
						type="button"
						data-fits-url="https://fits.gsfc.nasa.gov/samples/FUV.fits"
						data-label="GALEX FUV — M101 Spiral"
						data-colormap="plasma"
					>
						Pinwheel Galaxy (GALEX)
					</button>
				</div>
			</div>
			<p class="notice" id="aladin-hint">
				Upload high-resolution FITS files from NASA missions or paste a link to remote data sets. Large imagery may take a moment to render.
			</p>
			<p class="notice hidden" id="aladin-error" role="alert"></p>
		</aside>
		<div id="marker-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="marker-modal-title">
			<form class="modal__content">
				<h2 id="marker-modal-title">Add marker</h2>
				<p class="modal__hint">Customize the marker details before saving it to the sky map.</p>
				<label for="marker-title">
					<span>Title</span>
					<input id="marker-title" name="marker-title" type="text" autocomplete="off" />
				</label>
				<label for="marker-description">
					<span>Description</span>
					<textarea id="marker-description" name="marker-description" rows="3"></textarea>
				</label>
				<label for="marker-color" class="modal__color-picker">
					<span>Marker color</span>
					<input id="marker-color" name="marker-color" type="color" value="#60A5FA" />
				</label>
				<div class="modal__actions">
					<button type="button" class="modal__button modal__button--secondary" data-action="cancel">Cancel</button>
					<button type="submit" class="modal__button modal__button--primary">Save marker</button>
				</div>
			</form>
		</div>
		<script>
			const { A } = window;
			if (!A) {
				console.error('Aladin Lite library failed to load.');
			}

			const statusMessage = document.getElementById('status-message');
			const errorBox = document.getElementById('aladin-error');
			const fileInput = document.getElementById('fits-file');
			const urlInput = document.getElementById('fits-url');
			const loadUrlButton = document.getElementById('load-url');
			const addMarkerButton = document.getElementById('add-marker');
			const removeMarkerButton = document.getElementById('remove-marker');
			const sampleButtons = Array.from(document.querySelectorAll('[data-fits-url]'));
			const markerModal = document.getElementById('marker-modal');
			const markerForm = markerModal ? markerModal.querySelector('form') : null;
			const markerTitleInput = markerModal ? markerModal.querySelector('#marker-title') : null;
			const markerDescriptionInput = markerModal ? markerModal.querySelector('#marker-description') : null;
			const markerColorInput = markerModal ? markerModal.querySelector('#marker-color') : null;
			const markerCancelButton = markerModal ? markerModal.querySelector('[data-action="cancel"]') : null;

			let aladinInstance = null;
			let currentRequestId = 0;
			const markerLayersByColor = new Map();
			const markerCatalogMap = new WeakMap();
			let isAddingMarker = false;
			let isRemovingMarker = false;
			let storedStatusText = statusMessage.textContent;
			let resolveMarkerDialog = null;
			const MARKER_DEFAULT_COLOR = '#60A5FA';
			let lastSelectedMarkerColor = MARKER_DEFAULT_COLOR;

			const DEFAULT_SAMPLE = sampleButtons.length
				? {
						url: sampleButtons[0].dataset.fitsUrl,
						label: sampleButtons[0].dataset.label,
						colormap: sampleButtons[0].dataset.colormap
				  }
				: null;

			function showError(message) {
				errorBox.textContent = message;
				errorBox.classList.remove('hidden');
			}

			function clearError() {
				errorBox.textContent = '';
				errorBox.classList.add('hidden');
			}

			function updateStatus(label, fov) {
				const parts = [];
				if (label) {
					parts.push(`Source: ${label}`);
				}
				if (Number.isFinite(fov)) {
					const span = Math.max(0.01, fov * 2);
					parts.push(`FoV ≈ ${span.toFixed(2)}°`);
				}
				statusMessage.textContent = parts.join(' · ') || 'Ready to load a FITS image.';
				storedStatusText = statusMessage.textContent;
			}

			function focusOnImage(ra, dec, fov) {
				if (Number.isFinite(ra) && Number.isFinite(dec)) {
					aladinInstance.gotoRaDec(ra, dec);
				}
				if (Number.isFinite(fov)) {
					const clamped = Math.min(60, Math.max(0.01, fov * 2));
					aladinInstance.setFoV(clamped);
				}
			}

			function configureImage(image, colormap) {
				if (!image) {
					return;
				}
				try {
					image.setColormap(colormap || 'magma', { stretch: 'sqrt' });
				} catch (error) {
					console.warn('Unable to update the FITS colormap', error);
				}
			}

			function deriveLabel(source) {
				if (typeof source === 'string') {
					try {
						const url = new URL(source);
						return url.hostname;
					} catch {
						return source;
					}
				}
				if (source && typeof source.name === 'string') {
					return `Local file: ${source.name}`;
				}
				return 'Custom FITS';
			}

			function normaliseHexColor(input) {
				if (typeof input !== 'string') {
					return null;
				}
				const match = input.trim().match(/^#([0-9a-f]{6})$/i);
				return match ? `#${match[1].toUpperCase()}` : null;
			}

			function ensureMarkerLayer(color) {
				if (!aladinInstance) {
					return null;
				}
				const normalizedColor = normaliseHexColor(color) || MARKER_DEFAULT_COLOR;
				const existing = markerLayersByColor.get(normalizedColor);
				if (existing) {
					return existing;
				}
				const catalog = A.catalog({
					name: `Markers ${normalizedColor}`,
					shape: 'marker',
					color: normalizedColor
				});
				markerLayersByColor.set(normalizedColor, catalog);
				aladinInstance.addCatalog(catalog);
				return catalog;
			}

			function isMarkerDialogOpen() {
				return Boolean(markerModal && !markerModal.classList.contains('hidden'));
			}

			function closeMarkerDialog(result) {
				if (!markerModal || !markerForm) {
					if (typeof resolveMarkerDialog === 'function') {
						resolveMarkerDialog(result);
						resolveMarkerDialog = null;
					}
					return;
				}
				markerModal.classList.add('hidden');
				markerModal.setAttribute('aria-hidden', 'true');
				markerForm.reset();
				if (markerColorInput) {
					markerColorInput.value = lastSelectedMarkerColor || MARKER_DEFAULT_COLOR;
				}
				if (typeof resolveMarkerDialog === 'function') {
					resolveMarkerDialog(result);
					resolveMarkerDialog = null;
				}
			}

			function openMarkerDialog(defaultTitle, defaultDescription, defaultColor) {
				const resolvedDefaultColor = normaliseHexColor(defaultColor) || MARKER_DEFAULT_COLOR;
				if (!markerModal || !markerForm || !markerTitleInput || !markerDescriptionInput || !markerColorInput) {
					if (typeof resolveMarkerDialog === 'function') {
						resolveMarkerDialog(null);
						resolveMarkerDialog = null;
					}
					return Promise.resolve({
						title: defaultTitle,
						description: defaultDescription,
						color: resolvedDefaultColor
					});
				}
				if (typeof resolveMarkerDialog === 'function') {
					resolveMarkerDialog(null);
					resolveMarkerDialog = null;
				}
				markerTitleInput.value = defaultTitle;
				markerDescriptionInput.value = defaultDescription;
				markerColorInput.value = resolvedDefaultColor;
				markerModal.classList.remove('hidden');
				markerModal.setAttribute('aria-hidden', 'false');
				return new Promise((resolve) => {
					resolveMarkerDialog = resolve;
					window.requestAnimationFrame(() => {
						markerTitleInput.focus();
						markerTitleInput.select();
					});
				});
			}

			function loadFits(source, options = {}) {
				if (!aladinInstance || !source) {
					return;
				}

				const requestId = ++currentRequestId;
				const label = options.label || deriveLabel(source);

				clearError();
				statusMessage.textContent = `Loading ${label}…`;
				const loadTimeout = window.setTimeout(() => {
					if (requestId !== currentRequestId) {
						return;
					}
					console.warn(`FITS load timed out: ${label}`);
					showError('The FITS file is taking longer than expected to respond. Please try again or use a different source.');
				}, options.timeout ?? 20000);

				let finished = false;

				const finish = () => {
					if (finished) {
						return;
					}
					finished = true;
					window.clearTimeout(loadTimeout);
					if (typeof options.onCleanup === 'function') {
						try {
							options.onCleanup();
						} catch (cleanupError) {
							console.warn('Cleanup callback failed', cleanupError);
						}
					}
				};

				const handleSuccess = (ra, dec, fov, image) => {
					if (requestId !== currentRequestId) {
						return;
					}
					finish();
					configureImage(image, options.colormap);
					focusOnImage(ra, dec, fov);
					updateStatus(label, fov);
				};

				const handleError = (error) => {
					if (requestId !== currentRequestId) {
						return;
					}
					finish();
					console.error('Failed to load FITS data', error);
					showError('Unable to load the FITS data. Please verify the file or URL and try again.');
				};

				try {
					const result = aladinInstance.displayFITS(source, options.params || {}, handleSuccess, handleError);
					if (result && typeof result.then === 'function') {
						result.catch(handleError).finally(finish);
					}
				} catch (error) {
					handleError(error);
				}
			}

			function handleFileSelection(event) {
				const [file] = event.target.files || [];
				if (!file) {
					return;
				}
				const objectUrl = URL.createObjectURL(file);
				loadFits(objectUrl, {
					label: `Local file: ${file.name}`,
					onCleanup: () => URL.revokeObjectURL(objectUrl)
				});
				event.target.value = '';
			}

			function handleUrlLoad() {
				const url = urlInput.value.trim();
				if (!url) {
					showError('Please enter a FITS file URL.');
					return;
				}
				try {
					new URL(url);
				} catch {
					showError('The URL appears to be invalid. Please double-check and try again.');
					return;
				}
				loadFits(url, { label: url });
			}

			function initialiseSampleButtons() {
				sampleButtons.forEach((button) => {
					button.addEventListener('click', () => {
						const { fitsUrl, label, colormap } = button.dataset;
						loadFits(fitsUrl, { label, colormap });
					});
				});
			}

			if (markerForm && markerTitleInput && markerDescriptionInput && markerColorInput) {
				markerForm.addEventListener('submit', (event) => {
					event.preventDefault();
					const chosenColor = normaliseHexColor(markerColorInput.value) || MARKER_DEFAULT_COLOR;
					closeMarkerDialog({
						title: markerTitleInput.value,
						description: markerDescriptionInput.value,
						color: chosenColor
					});
				});
			}

			if (markerCancelButton) {
				markerCancelButton.addEventListener('click', () => {
					closeMarkerDialog(null);
				});
			}

			if (markerModal) {
				markerModal.addEventListener('click', (event) => {
					if (event.target === markerModal) {
						closeMarkerDialog(null);
					}
				});
			}

			window.addEventListener('keydown', (event) => {
				if (event.key === 'Escape' && isMarkerDialogOpen()) {
					event.preventDefault();
					closeMarkerDialog(null);
				}
			});

			function toggleMarkerMode(active) {
				if (!aladinInstance) {
					showError('The viewer is not ready yet. Please wait a moment and try again.');
					return;
				}
				if (active) {
					toggleRemovalMode(false);
				}
				isAddingMarker = active;
				if (addMarkerButton) {
					addMarkerButton.classList.toggle('marker-control--active', isAddingMarker);
				}
				if (isAddingMarker) {
					storedStatusText = statusMessage.textContent;
					statusMessage.textContent = 'Click anywhere on the map to place a marker. Press Esc to cancel.';
				} else if (!isRemovingMarker) {
					statusMessage.textContent = storedStatusText;
				}
				if (!isAddingMarker) {
					window.removeEventListener('keydown', cancelMarkerModeOnEscape);
				} else {
					window.addEventListener('keydown', cancelMarkerModeOnEscape);
				}
			}

			function toggleRemovalMode(active) {
				if (!aladinInstance) {
					showError('The viewer is not ready yet. Please wait a moment and try again.');
					return;
				}
				if (active) {
					toggleMarkerMode(false);
				}
				isRemovingMarker = active;
				if (removeMarkerButton) {
					removeMarkerButton.classList.toggle('marker-control--active', isRemovingMarker);
				}
				if (isRemovingMarker) {
					storedStatusText = statusMessage.textContent;
					statusMessage.textContent = 'Click an existing marker to remove it. Press Esc to cancel.';
					window.addEventListener('keydown', cancelRemovalModeOnEscape);
				} else {
					window.removeEventListener('keydown', cancelRemovalModeOnEscape);
					if (!isAddingMarker) {
						statusMessage.textContent = storedStatusText;
					}
				}
			}

			function cancelMarkerModeOnEscape(event) {
				if (event.key === 'Escape') {
					if (isMarkerDialogOpen()) {
						return;
					}
					toggleMarkerMode(false);
				}
			}

			function cancelRemovalModeOnEscape(event) {
				if (event.key === 'Escape') {
					toggleRemovalMode(false);
				}
			}

			async function createMarkerAt(ra, dec) {
				const defaultTitle = `Marker @ RA ${ra.toFixed(3)}, Dec ${dec.toFixed(3)}`;
				const defaultDescription = `Coordinates: RA ${ra.toFixed(3)}, Dec ${dec.toFixed(3)}`;
				const dialogResult = await openMarkerDialog(defaultTitle, defaultDescription, lastSelectedMarkerColor);
				if (!dialogResult) {
					return false;
				}
				const trimmedTitle = (dialogResult.title || '').trim();
				const trimmedDescription = (dialogResult.description || '').trim();
				const validColor = normaliseHexColor(dialogResult.color) || MARKER_DEFAULT_COLOR;
				lastSelectedMarkerColor = validColor;
				const targetLayer = ensureMarkerLayer(validColor);
				if (!targetLayer) {
					showError('Unable to access the marker layer. Please try again in a moment.');
					return false;
				}
				const markerOptions = {
					popupTitle: trimmedTitle || defaultTitle,
					popupDesc: trimmedDescription || defaultDescription,
					color: validColor
				};
				const marker = A.marker(ra, dec, markerOptions);
				markerCatalogMap.set(marker, targetLayer);
				targetLayer.addSources([marker]);
				aladinInstance.gotoRaDec(ra, dec);
				const confirmation = `${markerOptions.popupTitle} saved at RA ${ra.toFixed(3)}, Dec ${dec.toFixed(3)}`;
				statusMessage.textContent = confirmation;
				storedStatusText = confirmation;
				return true;
			}

			async function initialiseViewer() {
				if (!A) {
					showError('Aladin Lite could not be loaded. Please check your connection and refresh the page.');
					return;
				}
				try {
					A.init.then(() => {
						aladinInstance = A.aladin('#aladin-lite-div', {
							cooFrame: 'icrs',
							projection: 'AIT',
							showCooGrid: false,
							fullScreen: true,
							fov: 5,
							target: 'M 31'
						});

						ensureMarkerLayer(MARKER_DEFAULT_COLOR);
						aladinInstance.on('click', async (point) => {
							if (!isAddingMarker || !point) {
								return;
							}
							const { ra, dec } = point;
							if (Number.isFinite(ra) && Number.isFinite(dec)) {
								await createMarkerAt(ra, dec);
							}
							toggleMarkerMode(false);
						});

							aladinInstance.on('objectClicked', (source) => {
								if (!isRemovingMarker || !source) {
									return;
								}
								let catalog = markerCatalogMap.get(source);
								if (!catalog) {
									for (const candidate of markerLayersByColor.values()) {
										if (candidate && typeof candidate.remove === 'function') {
											candidate.remove(source);
											catalog = candidate;
											break;
										}
									}
								} else {
									catalog.remove(source);
								}
								if (!catalog) {
									return;
								}
								const title = (source.data && source.data.popupTitle) || 'Marker';
								const confirmation = `${title} removed.`;
								statusMessage.textContent = confirmation;
								storedStatusText = confirmation;
								markerCatalogMap.delete(source);
								toggleRemovalMode(false);
							});
					});

					initialiseSampleButtons();
					if (DEFAULT_SAMPLE) {
						loadFits(DEFAULT_SAMPLE.url, DEFAULT_SAMPLE);
					} else {
						updateStatus(null);
					}
				} catch (error) {
					console.error('Aladin Lite failed to initialise', error);
					showError('The Aladin Lite viewer could not be initialised. Please refresh the page.');
				}
			}

			fileInput.addEventListener('change', handleFileSelection);
			fileInput.addEventListener('click', () => {
				clearError();
			});

			loadUrlButton.addEventListener('click', handleUrlLoad);
			urlInput.addEventListener('keydown', (event) => {
				if (event.key === 'Enter') {
					event.preventDefault();
					handleUrlLoad();
				}
			});
			addMarkerButton.addEventListener('click', () => {
				toggleMarkerMode(!isAddingMarker);
			});
			if (removeMarkerButton) {
				removeMarkerButton.addEventListener('click', () => {
					toggleRemovalMode(!isRemovingMarker);
				});
			}

			initialiseViewer();
		</script>
	</body>
</html>
